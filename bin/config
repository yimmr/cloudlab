#!/bin/bash

export LANG=en_US.UTF-8

set -euo pipefail

echo -e "\033[36m(oﾟvﾟ)ノ\033[0m 接下来如果程序报错退出，则可以调用 \033[0;32m./bin/config\033[0m 继续安装~"

SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

source "$SCRIPT_DIR/utils.sh"
source "$SCRIPT_DIR/hysteria.sh"

# 只加载 SITE_DOMAIN 变量
if [[ -f "$PROJECT_DIR/.env" ]]; then
    SITE_DOMAIN=$(grep -E "^SITE_DOMAIN=" "$PROJECT_DIR/.env" 2>/dev/null | cut -d'=' -f2- | tr -d '"' | tr -d "'" || echo "")
fi
domain=$(prompt "[必填]请输入客户端访问域名: " "${SITE_DOMAIN:-}")

if [ -z "$domain" ]; then
    echo -e "\033[0;31m未提供域名\033[0m "
    exit 1
fi

# cf_token=$(prompt "Cloudflare API令牌（或留空回车跳过申请证书）: " "")

# if [ -n "$cf_token" ]; then
#     ssl_domain=$(prompt "申请证书的域名（多域名用,分隔）: " "$domain")
#     ssl_domain=${ssl_domain:-$domain}
# fi

# if [ -n "$cf_token" ] && [ -n "$ssl_domain" ]; then
#     mail=$(prompt "订阅域名通知的邮箱地址（或留空回车拒绝通知）: " "")
#     if [ -n "$mail" ]; then
#         mail="-m $mail"
#     fi
#     echo -e "\033[32m::\033[0m 正在申请证书..."
#     rm -rf certbot
#     ./bin/cert auto -d $ssl_domain -t $cf_token $mail -r false
#     echo -e "\033[32m✓\033[0m 申请证书成功！"
# else
#     echo -e "\033[32m::\033[0m 已跳过申请证书"
# fi

bw_up=$(prompt "带宽上传（纯数字mbps，仅配置客户端）: " "")

bw_down=$(prompt "带宽下载（纯数字mbps，仅配置客户端）: " "")

port=$(prompt "协议监听的端口: " "443")

hop_range=$(prompt "请输入跳跃端口范围 (格式如 20000:50000): " "20000:50000")

password=$(prompt "请输入客户端访问密码（或留空回车用随机密码）: " "")
if [ -z "$password" ]; then
    password=$(generate_password)
fi

log_step "开始更新环境变量 (.env 文件) ..."
ENV_FILE="$PROJECT_DIR/.env"
DEFAULT_ENV_NAME=".env.def"
DEFAULT_ENV_FILE="$PROJECT_DIR/$DEFAULT_ENV_NAME"

if [ ! -f "$ENV_FILE" ]; then
    echo -e "\033[32m::\033[0m不存在 .env 文件，正在从 $DEFAULT_ENV_NAME 复制..."
    if [ -f "$DEFAULT_ENV_FILE" ]; then
        cp "$DEFAULT_ENV_FILE" "$ENV_FILE"
        echo -e "\033[32m::\033[0m已创建 .env 文件"
    else
        echo -e "\033[31m::\033[0m错误：不存在 $DEFAULT_ENV_NAME 文件"
        exit 1
    fi
fi

SITE_DOMAIN=$domain
VARS=("SITE_DOMAIN")
env_content=$(cat "$ENV_FILE")
echo -e "\033[32m::\033[0m正在更新 .env 文件..."
for var in "${VARS[@]}"; do
    if [ -n "${!var}" ]; then
        escaped_value=$(printf '%s\n' "${!var}" | sed 's:[\/&]:\\&:g')
        env_content=$(echo "$env_content" | sed -E "s/^($var=).*/\1$escaped_value/")
    fi
done
echo "$env_content" > "$ENV_FILE"

echo -e "\033[32m::\033[0m已更新 .env 文件"

log_step "开始安装和配置 hysteria2 ..."

install_hysteria_if

log_step "正在重启公共容器（Caddy代理、数据库等） ..."
docker compose down || true
docker compose up -d
log_step "公共容器重启完成"

tlsdir="/etc/hysteria/certs"

# 检查目录是否存在且为空，如果为空则等待
if [ ! -d "$tlsdir" ] || [ -z "$(ls -A "$tlsdir" 2>/dev/null)" ]; then
    log_step "等待 Docker 容器生成证书目录..."
    max_wait=60  # 最大等待时间（秒）
    wait_interval=2  # 检查间隔（秒）
    elapsed=0

    while ([ ! -d "$tlsdir" ] || [ -z "$(ls -A "$tlsdir" 2>/dev/null)" ]) && [ $elapsed -lt $max_wait ]; do
        echo -e "\033[33m等待目录创建或文件生成: $tlsdir (已等待 ${elapsed}秒)...\033[0m"
        sleep $wait_interval
        elapsed=$((elapsed + wait_interval))
    done

    if [ ! -d "$tlsdir" ] || [ -z "$(ls -A "$tlsdir" 2>/dev/null)" ]; then
        log_err "超时：目录 $tlsdir 未在 ${max_wait} 秒内创建或生成文件"
        exit 1
    fi

    echo -e "\033[32m✓\033[0m 证书目录已就绪: $tlsdir"
else
    echo -e "\033[32m✓\033[0m 证书目录已存在且有内容: $tlsdir"
fi

chmod -R 755 $tlsdir

configure_hysteria "$domain" "$password" "$port" "$tlsdir" "$bw_up" "$bw_down" "$hop_range"